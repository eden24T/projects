classdef UserProblem < PROBLEM
%UserProblem - User-defined problem.
%
%   This problem provides a general framework, whose details can be defined
%   by the inputs of the constructor.
%
% All the acceptable properties:
%   encoding  	<string>            encoding scheme of each decision variable (1.real 2.integer 3.label 4.binary 5.permutation)
%   lower    	<vector>            lower bound of each decision variable
%   upper      	<vector>            upper bound of each decision variable
%   initFcn     <function handle>   function for initializing solutions
%   evalFcn     <function handle>   function for evaluating solutions
%   decFcn      <function handle>   function for repairing invalid solutions
%   objFcn     	<function handle>   objective functions
%   conFcn     	<function handle>   constraint functions
%   objGradFcn  <function handle>   function for calculating the gradients of objectives
%   objConFcn   <function handle>   function for calculating the gradients of constraints
%   data        <any>               data of the problem

%------------------------------- Copyright --------------------------------
% Copyright (c) 2023 BIMK Group. You are free to use the PlatEMO for
% research purposes. All publications which use this platform or any code
% in the platform should acknowledge the use of "PlatEMO" and reference "Ye
% Tian, Ran Cheng, Xingyi Zhang, and Yaochu Jin, PlatEMO: A MATLAB platform
% for evolutionary multi-objective optimization [educational forum], IEEE
% Computational Intelligence Magazine, 2017, 12(4): 73-87".
%--------------------------------------------------------------------------

    properties(SetAccess = protected)
        initFcn    = {};        % Function for initializing solutions
        evalFcn    = {};        % Function for evaluating solutions
        decFcn     = {};    	% Function for repairing invalid solutions
        objFcn     = {};     	% Objective functions
        conFcn     = {};     	% Constraint functions
        objGradFcn = {};        % Function for calculating the gradients of objectives
        conGradFcn = {};        % Function for calculating the gradients of constraints
        data       = {};        % Data of the problem
        
    end
    
    methods
        %% Constructor
        
        function obj = UserProblem(varargin)
            isStr = find(cellfun(@ischar,varargin(1:end-1))&~cellfun(@isempty,varargin(2:end)));
            for i = isStr(ismember(varargin(isStr),{'N','M','D','maxFE','maxRuntime','encoding','lower','upper','initFcn','evalFcn','decFcn','objFcn','conFcn','objGradFcn','conGradFcn','data'}))
                obj.(varargin{i}) = varargin{i+1};
            end
            if isempty(obj.D)
                obj.encoding = Str2Fcn(obj.encoding,1,[],'encoding scheme');
                %obj.D = length(obj.encoding); % D is the number of weights
                obj.D = 32; % D is the number of weights
            else
                obj.encoding = Str2Fcn(obj.encoding,1,[],'encoding scheme',obj.D);
            end
            if isempty(obj.M)
                obj.M = 2;
            end
            if isempty(obj.N)
                obj.N = 100;
            end
            obj.lower      = Str2Fcn(obj.lower,1,[],'lower bound',obj.D);
            obj.upper      = Str2Fcn(obj.upper,1,[],'upper bound',obj.D);
            % Define lower and upper bounds
            %obj.lower = -10 * ones(1, obj.D); % Lower bound for each variable
            %Pobj.upper = 10 * ones(1, obj.D);  % Upper bound for each variable
            obj.data       = Str2Fcn(obj.data,1,[],'dataset');
            obj.initFcn    = Str2Fcn(obj.initFcn,2,~isempty(obj.data),'initialization function');
            obj.evalFcn    = Str2Fcn(obj.evalFcn,3,~isempty(obj.data),'evaluation function');
            obj.decFcn     = Str2Fcn(obj.decFcn,3,~isempty(obj.data),'repair function');
            obj.objFcn     = Strs2Fcns(obj.objFcn,4,~isempty(obj.data),'objective function f');
            obj.conFcn     = Strs2Fcns(obj.conFcn,4,~isempty(obj.data),'constraint function g');
            obj.objGradFcn = Strs2Fcns(obj.objGradFcn,3,~isempty(obj.data),'gradient of objective fg');
            obj.conGradFcn = Strs2Fcns(obj.conGradFcn,3,~isempty(obj.data),'gradient of constraint gg');
            Pop   = obj.Initialization(100);
            %obj.M = length(Pop.objs);
            %obj.M = 2;
        end
        %% Generate initial solutions
        function Population = Initialization(obj,N)
            if nargin < 2
                N = obj.N;
            end
            if ~isempty(obj.initFcn)
                Population = obj.Evaluation(CallFcn(obj.initFcn,N,obj.data,'initialization function',[N obj.D]));
            else
                Population = Initialization@PROBLEM(obj,N);
            end
            %disp(size(Population.objs));
            obj.optimum = max(Population.objs,[],1);
        end
        %% Evaluate multiple solutions
        function Population = Evaluation(obj,varargin)
            if ~isempty(obj.evalFcn)
                for i = 1 : size(varargin{1},1)
                    [PopDec(i,:),PopObj(i,:),PopCon(i,:)] = CallFcn(obj.evalFcn,varargin{1}(i,:),obj.data,'evaluation function',[1 obj.D]);
                end
                Population = SOLUTION(PopDec,PopObj,PopCon,varargin{2:end});
                obj.FE     = obj.FE + length(Population);
            else
                a=varargin{1};
                Population = Evaluation@PROBLEM(obj,varargin{1});
            end
        end
        %% Repair invalid solutions
        function PopDec = CalDec(obj,PopDec)
            if ~isempty(obj.decFcn)
                for i = 1 : size(PopDec,1)
                    PopDec(i,:) = CallFcn(obj.decFcn,PopDec(i,:),obj.data,'repair function',[1 obj.D]);
                end
            else
                PopDec = CalDec@PROBLEM(obj,PopDec);
                % Define the network weights
                inputToHiddenWeights_Kv = randn(obj.N, 4);
                hiddenToOutputWeights_Kv = randn(obj.N, 4);
                inputToHiddenWeights_Kp = randn(obj.N, 4);
                hiddenToOutputWeights_Kp = randn(obj.N, 4);
                % Define the bias terms
                hiddenBias_Kv = randn(obj.N, 4);
                outputBias_Kv = randn(obj.N, 4);
                hiddenBias_Kp = randn(obj.N, 4);
                outputBias_Kp = randn(obj.N, 4);
                PopDec(:,1:4) = inputToHiddenWeights_Kv ;
                PopDec(:,5:8) = hiddenToOutputWeights_Kv;
                PopDec(:,17:20) = inputToHiddenWeights_Kp;
                PopDec(:,21:24) = hiddenToOutputWeights_Kp;
                PopDec(:,9:12) = hiddenBias_Kv;
                PopDec(:,13:16) = outputBias_Kv;
                PopDec(:,25:28) = hiddenBias_Kp;
                PopDec(:,29:32) = outputBias_Kp;

            end
        end
        

        %% Calculate objective values
        function [PopObj, PopCon] = CalObj(obj,PopDec) % PopObj=objective_values, PopDec=weights
            
                if ~isempty(obj.objFcn)
                    PopObj = zeros(size(PopDec,1),length(obj.objFcn));
                    for i = 1 : size(PopDec,1)
                        for j = 1 : length(obj.objFcn)
                            PopObj(i,j) = CallFcn(obj.objFcn{j},PopDec(i,:),obj.data,sprintf('objective function f%d',j),[1 1]);
                        end
                    end
                else
                    PopObj = CalObj@PROBLEM(obj,PopDec);
                    M = obj.M;
                    N = obj.N;
                    PopObj = zeros(N,M); 
                    f_obj = zeros(M,1);
                    for k = 1:N
                     for i = 1:M 
                        if i==1
                            m_load = 0.7; %mass of the load at the end of the arm;
                        else
                            m_load = 1; %mass of the load at the end of the arm;
                        end    
                        all_time = 0.1 : 0.1 : 5;
                        m1_sam = 0.1; % Mass of link 1
                        m2 = 0.2; % Mass of link 2
                        L1_sam = 1; % Length of link 1 % Adham (changed to suit the working area)
                        L2_sam = 0.5; % Length of link 2 % Adham (changed to suit the working area)
                        c1_sam = 0.03; % Viscouse friction coefficient for joint 1
                        c2_sam = 0.05; % Viscouse friction coefficient for joint 2
                        power = 1;
                        m2_sam = m2 + m_load; % Mass of link 2 including load at the end of the arm
                        g = 9.81;
                        tspan = 0:0.1:5;
                        y0 = [-12.61*pi/180; 69.36*pi/180; 0; 0]; % Initial condition [theta1 theta2; theta1_dot theta2_dot]
                        m1_model = 0.15;
                        m2_model = 0.35;
                        m_load_model = 0.35;
                        m2_model = m2_model + m_load_model;
                        L1_model = 0.4;
                        L2_model = 0.2;
                        c1_model = 0.03;
                        c2_model = 0.05;
                        % Define the network weights
                        inputToHiddenWeights_Kv = PopDec(k,1:4);
                        hiddenToOutputWeights_Kv = PopDec(k,5:8);
                        inputToHiddenWeights_Kp = PopDec(k,17:20);
                        hiddenToOutputWeights_Kp = PopDec(k,21:24);
                        % Define the bias terms
                        %hiddenBias_Kv = randn(hiddenSize, 2);
                        %outputBias_Kv = randn(outputSize, 2);
                        %hiddenBias_Kp = randn(hiddenSize, 2);
                        %outputBias_Kp = randn(outputSize, 2);
                        hiddenBias_Kv = PopDec(k,9:12);
                        outputBias_Kv = PopDec(k,13:16);
                        hiddenBias_Kp = PopDec(k,25:28);
                        outputBias_Kp = PopDec(k,29:32);
                        length_line = length(inputToHiddenWeights_Kv)/2;
                        line1 = inputToHiddenWeights_Kv(1,1:length_line);
                        a = length_line+1;
                        l = length(inputToHiddenWeights_Kv);
                        line2 = inputToHiddenWeights_Kv(1,a:l);
                        inputToHiddenWeights_Kv = [line1; line2];
    
                        length_line = length(hiddenToOutputWeights_Kv)/2;
                        line1 = hiddenToOutputWeights_Kv(1,1:length_line);
                        a = length_line+1;
                        l = length(hiddenToOutputWeights_Kv);
                        line2 = hiddenToOutputWeights_Kv(1,a:l);
                        hiddenToOutputWeights_Kv = [line1; line2];
    
                        length_line = length(inputToHiddenWeights_Kp)/2;
                        line1 = inputToHiddenWeights_Kp(1,1:length_line);
                        a = length_line+1;
                        l = length(inputToHiddenWeights_Kp);
                        line2 = inputToHiddenWeights_Kp(1,a:l);
                        inputToHiddenWeights_Kp = [line1; line2];
    
                        length_line = length(hiddenToOutputWeights_Kp)/2;
                        line1 = hiddenToOutputWeights_Kp(1,1:length_line);
                        a = length_line+1;
                        l = length(hiddenToOutputWeights_Kp);
                        line2 = hiddenToOutputWeights_Kp(1,a:l);
                        hiddenToOutputWeights_Kp = [line1; line2];
    
                        length_line = length(hiddenBias_Kv)/2;
                        line1 = hiddenBias_Kv(1,1:length_line);
                        a = length_line+1;
                        l = length(hiddenBias_Kv);
                        line2 = hiddenBias_Kv(1,a:l);
                        hiddenBias_Kv = [line1; line2];
    
                        length_line = length(outputBias_Kv)/2;
                        line1 = outputBias_Kv(1,1:length_line);
                        a = length_line+1;
                        l = length(outputBias_Kv);
                        line2 = outputBias_Kv(1,a:l);
                        outputBias_Kv = [line1; line2];
    
                        length_line = length(hiddenBias_Kp)/2;
                        line1 = hiddenBias_Kp(1,1:length_line);
                        a = length_line+1;
                        l = length(hiddenBias_Kp);
                        line2 = hiddenBias_Kp(1,a:l);
                        hiddenBias_Kp = [line1; line2];
    
                        length_line = length(outputBias_Kp)/2;
                        line1 = outputBias_Kp(1,1:length_line);
                        a = length_line+1;
                        l = length(outputBias_Kp);
                        line2 = outputBias_Kp(1,a:l);
                        outputBias_Kp = [line1; line2];
                        % Define network architecture
                        inputSize = size(inputToHiddenWeights_Kv, 2);
                        outputSize = size(hiddenToOutputWeights_Kv, 1);
                        hiddenSize = size(hiddenBias_Kv, 1);
                        % Input data
                        inputData = randn(inputSize,hiddenSize);
                        % Call the calcGains function to obtain K_v and K_p
                        %[K_v, K_p] = calcGains(inputData, inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, hiddenBias_Kv, outputBias_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kp, outputBias_Kp);
                        [t, y] = ode45(@(t, y) arm(t, y, m1_sam, m2_sam, m2, L1_sam, L2_sam, c1_sam, c2_sam, g, power, m1_model, m2_model, L1_model, L2_model, c1_model, c2_model,inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kv, outputBias_Kv, hiddenBias_Kp, outputBias_Kp), tspan, y0);
                        for j = 1:numel(t)
                          [~,theta_2dot_actual(j,:),tau] = arm(t(j), y(j,:), m1_sam, m2_sam, m2, L1_sam, L2_sam, c1_sam, c2_sam, g, power, m1_model, m2_model, L1_model, L2_model, c1_model, c2_model, inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kv, outputBias_Kv, hiddenBias_Kp, outputBias_Kp);
                        end
                        [x_t_D, Vx_t_D, Ax_t_D, y_t_D, Vy_t_D, Ay_t_D] = trajectory(t);
                        [x_actual, y_actual, x_dot_actual, y_dot_actual, x_2dot_actual, y_2dot_actual] = FOR_KIN(y(:,1), y(:,2), y(:,3), y(:,4), theta_2dot_actual(:,1), theta_2dot_actual(:,2), L1_model, L2_model);  
                        %[x_actual, y_actual, x_dot_actual, y_dot_actual, x_2dot_actual, y_2dot_actual] = FOR_KIN(y(k,1), y(k,2), y(k,3), y(k,4), theta_2dot_actual(k,1), theta_2dot_actual(k,2), L1_model, L2_model);  
                        R_a =  sqrt((x_actual.^2)+(y_actual.^2));
                        R_d =  sqrt((x_t_D.^2)+(y_t_D.^2));
                        R_a_dot = ((x_actual.*x_dot_actual)+(y_actual.*y_dot_actual))/sqrt((x_actual.^2)+(y_actual.^2));
                        R_d_dot = ((x_t_D.*Vx_t_D)+(y_t_D.*Vy_t_D))/sqrt((x_t_D.^2)+(y_t_D.^2));
                        %R_a_2dot = sqrt((x_2dot_actual^2)+(y_2dot_actual^2));
                        %R_d_2dot = sqrt((Ax_t_D^2)+(Ay_t_D^2));
                        %f1 = @(t) (R_a - R_d).^2;
                        ts_i = length(t);
                        f_obj(i) = sum((R_a(1:ts_i) - R_d(1:ts_i)).^2)/ts_i;
                        %f_obj(i) = @(t) ((R_a - R_d).^2);
                        %PopObj(:,i) = integral(f1,1,1.5,'ArrayValued',true);
                        %PopObj(1:size(integral),i) = integral;
                        PopObj(k,i) = f_obj(i);
                        %PopObj(k,i) = integral(f_obj(i)/5,0,5,'ArrayValued',true);
                     end
                    end
                end
                %PopCon = Evaluate_constraints(PopDec);
        end
            
             
        
            
        

        %% Calculate constraint violations
        function PopCon = CalCon(obj,PopDec)
            % This function calculates the constraint violations.
            % PopDec is the decision variable matrix. Each row is a solution.
            if ~isempty(obj.conFcn)
                PopCon = zeros(size(PopDec,1),length(obj.conFcn));
                for i = 1 : size(PopDec,1)
                    for j = 1 : length(obj.conFcn)
                        PopCon(i,j) = CallFcn(obj.conFcn{j},PopDec(i,:),obj.data,sprintf('constraint function g%d',j),[1 1]);
                    end
                end
            else
                PopCon = CalCon@PROBLEM(obj,PopDec);
                N = obj.N;
                PopCon = zeros(N, 2); % 2 columns for 2 constraints
                for k = 1:N
                    solution = PopDec(k,:);
                    PopCon(k,:) = constraint(obj, solution);
                end
            end
        end
             
        
        
        %% Calculate the gradients of objectives
        function ObjGrad = CalObjGrad(obj,Dec)
            if ~isempty(obj.objGradFcn)
                ObjGrad = zeros(length(obj.objGradFcn),obj.D);
                for i = 1 : length(obj.objGradFcn)
                    ObjGrad(i,:) = CallFcn(obj.objGradFcn{i},Dec,obj.data,sprintf('gradient of objective fg%d',i),[1 obj.D]);
                end
            else
                ObjGrad = CalObjGrad@PROBLEM(obj,Dec);
            end
        end
        %% Calculate the gradients of constraints
        function ConGrad = CalConGrad(obj,Dec)
            if ~isempty(obj.conGradFcn)
                ConGrad = zeros(length(obj.conGradFcn),obj.D);
                for i = 1 : length(obj.conGradFcn)
                    ConGrad(i,:) = CallFcn(obj.conGradFcn{i},Dec,obj.data,sprintf('gradient of constraint gg%d',i),[1 obj.D]);
                end
            else
                ConGrad = CalConGrad@PROBLEM(obj,Dec);
            end
        end
    end
end

function var = Str2Fcn(var,type,useData,name,D)
% Convert a string into a variable or function and check its validity

    if ischar(var)
        try
            if ~isempty(regexp(var,'^<.+>$','once'))
                switch type
                    case 1      % For lower, upper, data
                        var = load(var(2:end-1));
                    otherwise   % For initFcn, evalFcn, decFcn, objFcn, conFcn, objGradFcn, objConFcn
                        [folder,file,ext] = fileparts(var(2:end-1));
                        if type ~= 4 || strcmp(ext,'.m')
                            addpath(folder);
                            var = str2func(file);
                        else
                            var = load(var(2:end-1));
                        end
                end
            else
                switch type
                    case 1      % For lower, upper, data
                        var = str2num(var);
                    case 2      % For initFcn
                        if useData
                            var = str2func(['@(N,data)',var]);
                        else
                            var = str2func(['@(N)',var]);
                        end
                    case {3,4}	% For evalFcn, decFcn, objFcn, conFcn, objGradFcn, objConFcn
                        if useData
                            var = str2func(['@(x,data)',var]);
                        else
                            var = str2func(['@(x)',var]);
                        end
                end
            end
        catch err
            err = addCause(err,MException('','Fail to define the %s',name));
            rethrow(err);
        end
    end
    if type == 1 && nargin > 4      % For lower, upper, data
        if isscalar(var)
            var = repmat(var,1,D);
        else
            assert(ismatrix(var)&&all(size(var)==[1,D]),'the %s should be a scalar or a 1*%d vector, while its current size is %d*%d.',name,D,size(var,1),size(var,2));
        end
    end
    if type == 4 && isnumeric(var)   % For objFcn, conFcn
        try
            fprintf('Fit the %s...\n',name);
            Model = fitrgp(var(:,1:end-1),var(:,end),'OptimizeHyperparameters','all','HyperparameterOptimizationOptions',struct('ShowPlots',false,'Verbose',0));
            var   = @(x)predict(Model,x);
        catch err
            err = addCause(err,MException('','Fail to fit the %s',name));
            rethrow(err);
        end
    end
end

function Var = Strs2Fcns(Var,type,useData,name)
% Convert multiple strings into functions

    if ~iscell(Var)
        Var = {Var};
    end
    Var(cellfun(@isempty,Var)) = [];
    for i = 1 : length(Var)
        Var{i} = Str2Fcn(Var{i},type,useData,[name,num2str(i)]);
    end
end

function varargout = CallFcn(func,input,data,name,varargin)
% Call a function and check the validity of its output

    try
        if isempty(data)
            [varargout{1:nargout}] = func(input);
        else
            [varargout{1:nargout}] = func(input,data);
        end
        for i = 1 : min(length(varargout),length(varargin))
            assert(ismatrix(varargout{i})&&all(size(varargout{i})==varargin{i}),'the size of its output #%d should be %d*%d, while its current size is %d*%d.',i,varargin{i}(1),varargin{i}(2),size(varargout{i},1),size(varargout{i},2));
        end
    catch err
        err = addCause(err,MException('','The %s is invalid',name));
        rethrow(err);
    end
end

function [K_v, K_p] = calcGains(inputData, inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, hiddenBias_Kv, outputBias_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kp, outputBias_Kp)
    % Call the feedForNN function with provided weights and bias, we want the matrices to be diagonal
    K_v_diagon = diag(feedForNN(inputData, inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, hiddenBias_Kv, outputBias_Kv));
    K_p_diagon = diag(feedForNN(inputData, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kp, outputBias_Kp));
    K_v = diag(K_v_diagon);
    K_p = diag(K_p_diagon);
end

function [dydt,theta_2dot_actual,tau] = arm(t, y, m1_sam, m2_sam, m2, L1_sam, L2_sam, c1_sam, c2_sam, g, power, m1_model, m2_model, L1_model, L2_model, c1_model, c2_model, inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kv, outputBias_Kv, hiddenBias_Kp, outputBias_Kp)
    theta1 = y(1);
    theta2 = y(2);
    theta1_dot = y(3);
    theta2_dot = y(4);
    
    theta =  [theta1; theta2];
    theta_dot = [theta1_dot; theta2_dot];
    
    
    [x_t_D, Vx_t_D, Ax_t_D, y_t_D, Vy_t_D, Ay_t_D] = trajectory(t);
    theta_D_inv = INV_KIN(x_t_D, y_t_D, L1_model, L2_model);
    [J, J_inv, det_J] = jacobian(theta_D_inv, L1_model, L2_model, t);
    theta_dotD_inv = J_inv * [Vx_t_D; Vy_t_D];
    J_inv_dot = jacobian_inv_dot(theta_D_inv, theta_dotD_inv, J, det_J, L1_model, L2_model, t);
    theta_2dotD_inv = J_inv_dot * [Vx_t_D; Vy_t_D] + J_inv * [Ax_t_D; Ay_t_D];
    
    
    
    % Input data
    %inputData = randn(inputSize,2);
    error = [theta_D_inv - theta, theta_dotD_inv - theta_dot];
    inputData = error;
    % Call the calcGains function to obtain K_v and K_p
    [K_v, K_p] = calcGains(inputData, inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, hiddenBias_Kv, outputBias_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kp, outputBias_Kp);
    %disp(K_p);
    %disp(K_v);
    
    
    M = [m2_sam * L2_sam^2 + 2  * m2 * L1_sam *  L2_sam * cos(theta2) + (m1_sam + m2_sam) * L1_sam^2   m2_sam * L2_sam^2 + m2_sam * L1_sam * L2_sam * cos(theta2);
        m2_sam * L2_sam^2 + m2_sam * L1_sam * L2_sam * cos(theta2)      m2_sam * L2_sam^2]; % Inertia matrix
    Cor = [-m2_sam * L1_sam * L2_sam * sin(theta2) * theta1_dot^2 + -2 * m2_sam * L1_sam * L2_sam * sin(theta2) * theta2_dot * theta2_dot;  m2_sam * L1_sam * L2_sam * sin(theta2) * theta1_dot^2]; % Coriolis and centrifugal vector (V vector from stage 1)
    G = [(m1_sam  + m2_sam) * L1_sam * g * cos(theta1) + m2_sam * L2_sam * g * cos(theta1 + theta2);
        m2_sam * L2_sam * g * cos(theta1 + theta2)]; % Gravity vector
    F = [-c1_sam*(theta_dotD_inv(1)^power);
        -c2_sam*(theta_dotD_inv(2)^power)]; % Viscous friction vector
    
    
    M_model = [m2_model * L2_model^2 + 2  * m2 * L1_model *  L2_model * cos(theta2) + (m1_model + m2_model) * L1_model^2   m2_model * L2_model^2 + m2_model * L1_model * L2_model * cos(theta2);
        m2_model * L2_model^2 + m2_model * L1_model * L2_model * cos(theta2)      m2_model * L2_model^2]; % Inertia matrix calculated by the model parameters
    Cor_model = [-m2_model * L1_model * L2_model * sin(theta2) * theta1_dot^2 + -2 * m2_model * L1_model * L2_model * sin(theta2) * theta2_dot * theta2_dot;  m2_model * L1_model * L2_model * sin(theta2) * theta1_dot^2]; % Coriolis and centrifugal vector (V vector from stage 1) calculated by the model parameters
    G_model = [(m1_model  + m2_model) * L1_model * g * cos(theta1) + m2_model * L2_model * g * cos(theta1 + theta2);
        m2_model * L2_model * g * cos(theta1 + theta2)]; % Gravity vector calculated by the model parameters
    F_model = [-c1_model*(theta_dotD_inv(1)^power);
        -c2_model*(theta_dotD_inv(2)^power)]; % Viscous friction vector calculated by the model parameters
    
    alpha = M_model;
    beta = Cor_model + G_model + F_model;
    ftag = theta_2dotD_inv + K_v*(theta_dotD_inv-theta_dot) + K_p*(theta_D_inv - theta);
    f = alpha * ftag + beta; % Control law
    denomenator = f - Cor - G - F;
    theta_2dot_trn = denomenator \ M;
    theta_2dot = theta_2dot_trn.';
    theta_2dot_org = M \ denomenator;

    
     theta_2dot_actual = theta_2dot;
     tau = f;
    
    
    dydt = [theta1_dot;
        theta2_dot;
        theta_2dot(1);
        theta_2dot(2)];
end

%Defining desired trajectory as functions of time
function [x_t_D, Vx_t_D, Ax_t_D, y_t_D, Vy_t_D, Ay_t_D] = trajectory(t)
%x_t_D = zeros(size(t)); % Initialize position at x axis as a function of time
%y_t_D = zeros(size(t)); % Initialize position at y axis as a function of time
%Vx_t_D = zeros(size(t)); % Initialize velocity at x axis as a function of time
%Vy_t_D = zeros(size(t)); % Initialize velocity at y axis as a function of time
%Ax_t_D = zeros(size(t)); % Initialize acceleration at x axis as a function of time
%Ay_t_D = zeros(size(t)); % Initialize acceleration at y axis as a function of time
options = linspace(1.2, 1.3, 51); % Creates 51 evenly spaced numbers from 1 to 1.75
x0 = options(randi(length(options))); % Randomly selects one number from these options
%x0 = 1.250; % Start point
options = linspace(0.1, 0.3, 51); % Creates 51 evenly spaced numbers from 1 to 1.75
y0 = options(randi(length(options))); % Randomly selects one number from these options
%y0 = 0.2; % Start point
options = linspace(-0.3, -0.1, 51); % Creates 51 evenly spaced numbers from 1 to 1.75
xf = options(randi(length(options))); % Randomly selects one number from these options
%xf = -0.3; % End point
options = linspace(1.1, 1.3, 51); % Creates 51 evenly spaced numbers from 1 to 1.75
yf = options(randi(length(options))); % Randomly selects one number from these options
%yf = 1.3; % End point
tf = 5; % Time
Vx_0 = 0; % Start velocity
Vy_0 = 0; % Start velocity
Vx_f = 0; % End velocity
Vy_f = 0; % End velocity
a0 = x0; % a0=0
a1 = Vx_0; % a1=0
a2 = (3/(tf^2))*(xf-x0) - (2/tf)*Vx_0 - Vx_f/tf;
a3 = (-2/(tf^3))*(xf-x0) + (Vx_f+Vx_0)/(tf^2);
x_t_D = a0 + a1*t + a2*(t.^2) + a3*(t.^3);
Vx_t_D = a1 + 2*a2*t + 3*a3*(t.^2);
Ax_t_D = 2*a2 + 6*a3*t;
b0 = y0; % b0=0
b1 = Vy_0; % b1=0
b2 = (3/(tf^2))*(yf-y0) - (2/tf)*Vy_0 - Vy_f/tf;
b3 = (-2/(tf^3))*(yf-y0) + (Vy_f+Vy_0)/(tf^2);
y_t_D = b0 + b1*t + b2*(t.^2) + b3*(t.^3);
Vy_t_D = b1 + 2*b2*t + 3*b3*(t.^2);
Ay_t_D = 2*b2 + 6*b3*t;
end

function theta_D_inv = INV_KIN(x_t_D, y_t_D, L1_model, L2_model)
r = sqrt(x_t_D.^2 + y_t_D.^2); %The distance from the origin to the desired end effector position
cos_theta2 = (r.^2 - L1_model^2 - L2_model^2) / (2 * L1_model * L2_model); %Calculate theta2 using the law of cosines
if abs(cos_theta2) > 1
    error('Desired position is out of reach');
end
theta2_D_inv = acos(cos_theta2);
theta1_D_inv = atan2(y_t_D, x_t_D) - atan2((L2_model * sin(theta2_D_inv)), (L1_model + L2_model * cos(theta2_D_inv))); % Calculate theta1 using trigonometry
theta_D_inv = [theta1_D_inv; theta2_D_inv]; %Vector of desired angels after inverse kinematic conversion
end


function [J, J_inv, det_J] = jacobian(theta_D_inv, L1_model, L2_model, t)
J = zeros(2*length(t), 2); %Initialize the Jacobian matrix
J_inv = zeros(2*length(t), 2); %Initialize the inverse Jacobian matrix
% Calculate the elements of the Jacobian matrix
J(1, 1) = -L1_model * sin(theta_D_inv(1)) - L2_model * sin(theta_D_inv(1) + theta_D_inv(2));
J(1, 2) = -L2_model * sin(theta_D_inv(1) + theta_D_inv(2));
J(2, 1) = L1_model * cos(theta_D_inv(1)) + L2_model * cos(theta_D_inv(1) + theta_D_inv(2));
J(2, 2) = L2_model * cos(theta_D_inv(1) + theta_D_inv(2));
det_J = J(1, 1) * J(2, 2) - J(1, 2) * J(2, 1);
J_inv(1,1) = J(2, 2)/det_J;
J_inv(1,2) = -J(1, 2)/det_J;
J_inv(2,1) = -J(2, 1)/det_J;
J_inv(2,2) = J(1, 1)/det_J;
end


function J_inv_dot = jacobian_inv_dot(theta_D_inv, theta_dotD_inv, J, det_J, L1_model, L2_model,t)
J_inv_dot = zeros(2*length(t), 2); %Initialize the derivative of inverse Jacobian matrix
dot_det_J = (-L1_model*cos(theta_D_inv(1))*theta_dotD_inv(1) + -L2_model*cos(theta_D_inv(1)+theta_D_inv(2))*(theta_dotD_inv(1)+theta_dotD_inv(2)))*(L2_model*cos(theta_D_inv(1)+theta_D_inv(2))) + (-L2_model*sin(theta_D_inv(1)+theta_D_inv(2))*(theta_dotD_inv(1)+theta_dotD_inv(2)))*(-L1_model*sin(theta_D_inv(1)) + -L2_model*sin(theta_D_inv(1)+theta_D_inv(2))) - ((-L2_model*cos(theta_D_inv(1)+theta_D_inv(2))*(theta_dotD_inv(1)+theta_dotD_inv(2)))*(L1_model*cos(theta_D_inv(1))+L2_model*cos(theta_D_inv(1)+theta_D_inv(2))) + (-L1_model*sin(theta_D_inv(1))*theta_dotD_inv(1) + -L2_model*sin(theta_D_inv(1)+theta_D_inv(2))*(theta_dotD_inv(1)+theta_dotD_inv(2)))*(-L2_model*sin(theta_D_inv(1)+theta_D_inv(2))));
% Calculate the elements of the derivative of inverse jacobian matrix
J_inv_dot(1,1) = (((-L2_model * sin(theta_D_inv(1) + theta_D_inv(2))*(theta_dotD_inv(1) + theta_dotD_inv(2)))*det_J)-dot_det_J*J(2, 2))/(det_J^2);
J_inv_dot(1,2) = ((L2_model * cos(theta_D_inv(1) + theta_D_inv(2))*(theta_dotD_inv(1) + theta_dotD_inv(2))*det_J)+dot_det_J*J(1, 2))/(det_J^2);
J_inv_dot(2,1) = ((L1_model * sin(theta_D_inv(1))*theta_dotD_inv(1) + L2_model * sin(theta_D_inv(1) + theta_D_inv(2))*(theta_dotD_inv(1) + theta_dotD_inv(2)))*det_J + dot_det_J*J(2, 1))/(det_J^2);
J_inv_dot(2,2) = ((-L1_model * cos(theta_D_inv(1))*theta_dotD_inv(1)- L2_model * cos(theta_D_inv(1) + theta_D_inv(2))*(theta_dotD_inv(1) + theta_dotD_inv(2)))*det_J - dot_det_J*J(1, 1))/(det_J^2);
end


function [x_D_FOR, y_D_FOR, x_dot_D_FOR, y_dot_D_FOR, x_2dot_D_FOR, y_2dot_D_FOR] = FOR_KIN(theta1_D_inv, theta2_D_inv, theta1_dotD_inv, theta2_dotD_inv, theta1_2dotD_inv, theta2_2dotD_inv, L1_model, L2_model)
x_D_FOR = L1_model * cos(theta1_D_inv) + L2_model * cos(theta1_D_inv + theta2_D_inv); % Desired position at x axis after forward kinematic conversion
y_D_FOR = L1_model * sin(theta1_D_inv) + L2_model * sin(theta1_D_inv + theta2_D_inv); % Desired position at y axis after forward kinematic conversion
x_dot_D_FOR = -L1_model .* sin(theta1_D_inv) .* theta1_dotD_inv -L2_model .* sin(theta1_D_inv + theta2_D_inv) .* (theta1_dotD_inv + theta2_dotD_inv); % Desired velocity at x axis after forward kinematic conversion
y_dot_D_FOR = L1_model .* cos(theta1_D_inv) .* theta1_dotD_inv + L2_model .* cos(theta1_D_inv + theta2_D_inv) .* (theta1_dotD_inv + theta2_dotD_inv); % Desired velocity at y axis after forward kinematic conversion
x_2dot_D_FOR = -L1_model .* cos(theta1_D_inv) .* (theta1_dotD_inv.^2) -L1_model .* sin(theta1_D_inv) .* theta1_2dotD_inv - L2_model .* cos(theta1_D_inv + theta2_D_inv) .* ((theta1_dotD_inv + theta2_dotD_inv).^2) -L2_model .* sin(theta1_D_inv + theta2_D_inv) .* (theta1_2dotD_inv + theta2_2dotD_inv); % Desired acceleration at x axis after forward kinematic conversion
y_2dot_D_FOR = -L1_model .* sin(theta1_D_inv) .* (theta1_dotD_inv.^2) + L1_model .* cos(theta1_D_inv) .* theta1_2dotD_inv -L2_model .* sin(theta1_D_inv + theta2_D_inv) .* ((theta1_dotD_inv + theta2_dotD_inv).^2) + L2_model .* cos(theta1_D_inv + theta2_D_inv) .* (theta1_2dotD_inv + theta2_2dotD_inv); % Desired acceleration at y axis after forward kinematic conversion
%x_2dot_D_FOR = -L1_model * cos(theta1_D_inv) * (theta1_dotD_inv.^2) -L1_model * sin(theta1_D_inv) * theta1_2dotD_inv - L2_model * cos(theta1_D_inv + theta2_D_inv) * ((theta1_dotD_inv + theta2_dotD_inv).^2) -L2_model * sin(theta1_D_inv + theta2_D_inv) * (theta1_2dotD_inv + theta2_2dotD_inv); % Desired acceleration at x axis after forward kinematic conversion
%y_2dot_D_FOR = -L1_model * sin(theta1_D_inv) * (theta1_dotD_inv.^2) + L1_model * cos(theta1_D_inv) * theta1_2dotD_inv -L2_model * sin(theta1_D_inv + theta2_D_inv) * ((theta1_dotD_inv + theta2_dotD_inv).^2) + L2_model * cos(theta1_D_inv + theta2_D_inv) * (theta1_2dotD_inv + theta2_2dotD_inv); % Desired acceleration at y axis after forward kinematic conversion
end

function violation = constraint(obj, solution)
  % Solution is a row in PopDec
  PopDec = solution;
  M = obj.M;
  for i=1:M
      if i==1
         m_load = 0.5; %mass of the load at the end of the arm;
      else
         m_load = 1; %mass of the load at the end of the arm;
      end
      m1_sam = 0.1; % Mass of link 1
      m2 = 0.2; % Mass of link 2
      L1_sam = 1; % Length of link 1 % Adham (changed to suit the working area)
      L2_sam = 0.5; % Length of link 2 % Adham (changed to suit the working area)
      c1_sam = 0.03; % Viscouse friction coefficient for joint 1
      c2_sam = 0.05; % Viscouse friction coefficient for joint 2
      power = 1;
      m2_sam = m2 + m_load; % Mass of link 2 including load at the end of the arm
      g = 9.81;
      tspan = 0:0.1:5;
      y0 = [-12.61*pi/180; 69.36*pi/180; 0; 0]; % Initial condition [theta1 theta2; theta1_dot theta2_dot]
      m1_model = 0.15;
      m2_model = 0.35;
      m_load_model = 0.35;
      m2_model = m2_model + m_load_model;
      L1_model = 0.1;
      L2_model = 0.1;
      c1_model = 0.03;
      c2_model = 0.05;
      % Define the network weights
      inputToHiddenWeights_Kv = PopDec(1,1:4);
      hiddenToOutputWeights_Kv = PopDec(1,5:8);
      inputToHiddenWeights_Kp = PopDec(1,17:20);
      hiddenToOutputWeights_Kp = PopDec(1,21:24);
      % Define the bias terms
      %hiddenBias_Kv = randn(hiddenSize, 2);
      %outputBias_Kv = randn(outputSize, 2);
      %hiddenBias_Kp = randn(hiddenSize, 2);
      %outputBias_Kp = randn(outputSize, 2);
      hiddenBias_Kv = PopDec(1,9:12);
      outputBias_Kv = PopDec(1,13:16);
      hiddenBias_Kp = PopDec(1,25:28);
      outputBias_Kp = PopDec(1,29:32);
      length_line = length(inputToHiddenWeights_Kv)/2;
      line1 = inputToHiddenWeights_Kv(1,1:length_line);
      a = length_line+1;
      l = length(inputToHiddenWeights_Kv);
      line2 = inputToHiddenWeights_Kv(1,a:l);
      inputToHiddenWeights_Kv = [line1; line2];

      length_line = length(hiddenToOutputWeights_Kv)/2;
      line1 = hiddenToOutputWeights_Kv(1,1:length_line);
      a = length_line+1;
      l = length(hiddenToOutputWeights_Kv);
      line2 = hiddenToOutputWeights_Kv(1,a:l);
      hiddenToOutputWeights_Kv = [line1; line2];

      length_line = length(inputToHiddenWeights_Kp)/2;
      line1 = inputToHiddenWeights_Kp(1,1:length_line);
      a = length_line+1;
      l = length(inputToHiddenWeights_Kp);
      line2 = inputToHiddenWeights_Kp(1,a:l);
      inputToHiddenWeights_Kp = [line1; line2];

      length_line = length(hiddenToOutputWeights_Kp)/2;
      line1 = hiddenToOutputWeights_Kp(1,1:length_line);
      a = length_line+1;
      l = length(hiddenToOutputWeights_Kp);
      line2 = hiddenToOutputWeights_Kp(1,a:l);
      hiddenToOutputWeights_Kp = [line1; line2];

      length_line = length(hiddenBias_Kv)/2;
      line1 = hiddenBias_Kv(1,1:length_line);
      a = length_line+1;
      l = length(hiddenBias_Kv);
      line2 = hiddenBias_Kv(1,a:l);
      hiddenBias_Kv = [line1; line2];
    
      length_line = length(outputBias_Kv)/2;
      line1 = outputBias_Kv(1,1:length_line);
      a = length_line+1;
      l = length(outputBias_Kv);
      line2 = outputBias_Kv(1,a:l);
      outputBias_Kv = [line1; line2];

      length_line = length(hiddenBias_Kp)/2;
      line1 = hiddenBias_Kp(1,1:length_line);
      a = length_line+1;
      l = length(hiddenBias_Kp);
      line2 = hiddenBias_Kp(1,a:l);
      hiddenBias_Kp = [line1; line2];

      length_line = length(outputBias_Kp)/2;
      line1 = outputBias_Kp(1,1:length_line);
      a = length_line+1;
      l = length(outputBias_Kp);
      line2 = outputBias_Kp(1,a:l);
      outputBias_Kp = [line1; line2];
      % Define network architecture
      inputSize = size(inputToHiddenWeights_Kv, 2);
      outputSize = size(hiddenToOutputWeights_Kv, 1);
      hiddenSize = size(hiddenBias_Kv, 1);
      % Input data
      inputData = randn(inputSize,hiddenSize);
      % Call the calcGains function to obtain K_v and K_p
      %[K_v, K_p] = calcGains(inputData, inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, hiddenBias_Kv, outputBias_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kp, outputBias_Kp);
      [t, y] = ode45(@(t, y) arm(t, y, m1_sam, m2_sam, m2, L1_sam, L2_sam, c1_sam, c2_sam, g, power, m1_model, m2_model, L1_model, L2_model, c1_model, c2_model, inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kv, outputBias_Kv, hiddenBias_Kp, outputBias_Kp), tspan, y0);
      for j = 1:numel(t)
          [~,theta_2dot_actual(j,:),tau] = arm(t(j), y(j,:), m1_sam, m2_sam, m2, L1_sam, L2_sam, c1_sam, c2_sam, g, power, m1_model, m2_model, L1_model, L2_model, c1_model, c2_model,inputToHiddenWeights_Kv, hiddenToOutputWeights_Kv, inputToHiddenWeights_Kp, hiddenToOutputWeights_Kp, hiddenBias_Kv, outputBias_Kv, hiddenBias_Kp, outputBias_Kp);
      end
      [x_t_D, Vx_t_D, Ax_t_D, y_t_D, Vy_t_D, Ay_t_D] = trajectory(t);
      [x_actual, y_actual, x_dot_actual, y_dot_actual, x_2dot_actual, y_2dot_actual] = FOR_KIN(y(:,1), y(:,2), y(:,3), y(:,4), theta_2dot_actual(:,1), theta_2dot_actual(:,2), L1_model, L2_model);   
      R_a = sqrt((x_actual.^2)+(y_actual.^2));
      R_d = sqrt((x_t_D.^2)+(y_t_D.^2));
        %R_a_dot = sqrt((x_dot_actual^2)+(y_dot_actual^2));
        %R_d_dot = sqrt((Vx_t_D^2)+(Vy_t_D^2));
        %R_a_2dot = sqrt((x_2dot_actual^2)+(y_2dot_actual^2));
        %R_d_2dot = sqrt((Ax_t_D^2)+(Ay_t_D_^2));
  end
  constraint1_curr = ones(1,length(R_a));
  constraint1 = 1;
  %constraint1 = 0;
  for j = 1:length(R_a)
     g1 = abs(R_a(j) - R_d(j));
     %constraint1 = min(constraint1,(abs(R_a(j) - R_d(j))<=1));
     constraint1_curr(j) = min(1,(abs(g1)>=0.03));
  end
  for j = 1:length(constraint1_curr)
      if constraint1_curr(j) == 0
          constraint1 =0;
      end
      if constraint1 == 0
         if g1<=0
             viol1 = abs(g1);
         else 
             viol1 = g1;
         end
     elseif constraint1 == 1
         if g1<=0
             viol1 = g1 +3;
         else 
             viol1 = -g1 +3;
         end
     end
  end
 

  constraint2_curr = [1,1];
  constraint2 = 1;
  for j = 1:length(tau)
     g2 = tau(j);
     %g2 = tau;
     %constraint2 = min(constraint2,(tau(j) <= 4.5*(10^11)));
     constraint2_curr(j) = min(1,(-4.8<=g2 && g2 <= 0.15));
  end
  for j = 1:length(tau)
      if constraint2_curr(j) == 0
          constraint2 =0;
      end
      if constraint2 == 0
         if g2<=0
             viol2 = abs(g2);
         else 
             viol2 = g2;
         end
     elseif constraint2 == 1
         if g2<=0
             viol2 = g2 +3;
         else 
             viol2 = -g2 +3;
         end
      end
  end
 
  
  % if viol1<=0 && abs(viol1) >= 0.01
  %     viol2 = viol2 - 3;
  % end
  % if viol2<=0 && abs(viol2) >= 0.01
  %     viol2 = viol2 - 3;
  % end
  
  %violation = [max(constraint1, [], 2), constraint2];
  violation = [viol1, viol2];
  %disp(violation);
end